<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>ei1333's page</title>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="https://use.edgefonts.net/source-code-pro.js"></script>
    <link rel="stylesheet" href="../css/static.css">
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <header>
      <h1>ei1333's page</h1>
      <div class="path">
	<a href="../index.html">ホーム</a> &gt;
	<a href="index.html">Wiki</a>
      </div>
    </header>
    <main>
      <section>
	<h2>最小費用流(Primal-Dual)</h2>
	
	<h4>説明</h4>
	<p>最小費用流を最短路反復で解くアルゴリズム。始点から終点までの重みの最短路を求め、そこに流せる限り流す。これを流したい分だけ流しきるまで繰り返す。最短路の計算は、ポテンシャル $h$ を用いて負辺がないように変換して Dijkstra法 で求める。</p>

	<h4>計算量</h4>
	<p>$O(FE \log V)$</p>

	<h4>実装例</h4>
	<pre><code class="cpp">struct Primal_Dual
{
  const int INF = 1 &lt;&lt; 30;
  typedef pair&lt; int, int &gt; Pi;

  struct edge
  {
    int to, cap, cost, rev;
  };
  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; int &gt; potential, min_cost, prevv, preve;

  Primal_Dual(int V) : graph(V) {}

  void add_edge(int from, int to, int cap, int cost)
  {
    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});
    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});
  }

  int min_cost_flow(int s, int t, int f)
  {
    int V = graph.size(), ret = 0;
    priority_queue&lt; Pi, vector&lt; Pi &gt;, greater&lt; Pi &gt; &gt; que;
    potential.assign(V, 0);
    preve.assign(V, -1);
    prevv.assign(V, -1);

    while(f &gt; 0) {
      min_cost.assign(V, INF);
      que.push(Pi(0, s));
      min_cost[s] = 0;

      while(!que.empty()) {
        Pi p = que.top();
        que.pop();
        if(min_cost[p.second] &lt; p.first) continue;
        for(int i = 0; i &lt; graph[p.second].size(); i++) {
          edge &amp;e = graph[p.second][i];
          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];
          if(e.cap &gt; 0 &amp;&amp; min_cost[e.to] &gt; nextCost) {
            min_cost[e.to] = nextCost;
            prevv[e.to] = p.second, preve[e.to] = i;
            que.push(Pi(min_cost[e.to], e.to));
          }
        }
      }
      if(min_cost[t] == INF) return -1;
      for(int v = 0; v &lt; V; v++) potential[v] += min_cost[v];
      int addflow = f;
      for(int v = t; v != s; v = prevv[v]) {
        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);
      }
      f -= addflow;
      ret += addflow * potential[t];
      for(int v = t; v != s; v = prevv[v]) {
        edge &amp;e = graph[prevv[v]][preve[v]];
        e.cap -= addflow;
        graph[v][e.rev].cap += addflow;
      }
    }
    return ret;
  }
};</code></pre>
	<h4>問題例</h4>
      </section>
    </main>
    <hr>
    <footer>
      <small>Copyright&copy; ei1333's page All Rights Reserved.</small>
    </footer>

  </body>
</html>
