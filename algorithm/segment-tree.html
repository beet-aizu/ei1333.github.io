<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>ei1333's page</title>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <script src="https://use.edgefonts.net/source-code-pro.js"></script>
    <link rel="stylesheet" href="../css/static.css">
    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <header>
      <h1>ei1333's page</h1>
      <div class="path">
	<a href="../index.html">ホーム</a> &gt;
	<a href="index.html">Wiki</a>
      </div>
    </header>
    <main>
      <section>
	<h2>セグメント木(Segment-Tree)</h2>
	
	<h4>説明</h4>
	<p>完全2分木である。区間に対する様々な演算が$O(\log N)$で実現できるが, ここでは一般的な操作であるRMQを実装している。</p>

        <p>実装では木を配列で実現している。ノード $k$ について, 親ノードは $(k - 1) / 2$, 子ノードは $2k+1, 2k+2$ である。</p>

        <h4>使い方</h4>
        <ul>
          <li>set(k, x): $k$ 番目の要素に値 $x$ をセットする</li>
	  <li>build(): 構築する</li>
        </ul>
        
        <ul>
          <li>rmq(l, r): 区間 $[l, r)$ の最小値を求める</li>
          <li>update(k, x): $k$ 番目の要素を値 $x$ に変更する</li> 
        </ul>

	<h4>計算量</h4>
	<ul>
         <li>build: $O(N)$</li>
         <li>rmq, update: $O(\log N)$</li>
        </ul>
       
	<h4>実装例</h4>
	<pre><code class="cpp">struct SegmentTree
{
  vector&lt; int &gt; seg;
  int sz;
 
  SegmentTree(int n)
  {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    seg.assign(2 * sz - 1, INF);
  }

  void set(int k, int x)
  {
    seg[k + sz - 1] = x;
  }

  void build()
  {
    for(int k = sz - 2; k &gt;= 0; k--) {
      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);
    }  
  }

  int rmq(int a, int b, int k, int l, int r)
  {
    if(a &gt;= r || b &lt;= l) return(INF);
    if(a &lt;= l &amp;&amp; r &lt;= b) return(seg[k]);
    return(min(rmq(a, b, 2 * k + 1, l, (l + r) &gt;&gt; 1),
               rmq(a, b, 2 * k + 2, (l + r) &gt;&gt; 1, r)));
  }

  int rmq(int a, int b)
  {
    return(rmq(a, b, 0, 0, sz));
  }

  void update(int k, int x)
  {
    k += sz - 1;
    seg[k] = x;
    while(k &gt; 0) {
      k = (k - 1) &gt;&gt; 1;
      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);
    }
  }

};</code></pre>

        <h4>応用 1: 区間加算</h4>
        <p>Starry-Sky-Tree と呼ばれる有名なセグメント木がある。このセグメント木では以下の $2$ つのクエリをサポートする。</p>
        <ul>
          <li>区間 $[a, b)$ に一様に値 $x$ を加算する</li>
          <li>区間 $[a, b)$ に最小値を求める</li>
        </ul>
        <p>ここではその区間に一様に加算される値を持つ add 配列と, 区間の最小値を持つ small 配列を持つことによって実現している。</p>

        <pre><code class="cpp">struct SegmentTree
{
  const int INF = 1 &lt;&lt; 30;

  vector&lt; int &gt; small, add;
  int sz;

  SegmentTree(int n)
  {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    small.assign(2 * sz - 1, 0);
    add.assign(2 * sz - 1, 0);
  }

  inline void Merge(int k)
  {
    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);
  }

  int rmq(int a, int b, int k, int l, int r)
  {
    if(a &gt;= r || b &lt;= l) return (INF);
    if(a &lt;= l &amp;&amp; r &lt;= b) return (small[k] + add[k]);
    int L = rmq(a, b, 2 * k + 1, l, (l + r) &gt;&gt; 1);
    int R = rmq(a, b, 2 * k + 2, (l + r) &gt;&gt; 1, r);
    return (min(L, R) + add[k]);
  }

  void rangeadd(int a, int b, int x, int k, int l, int r)
  {
    if(a &gt;= r || b &lt;= l) return;
    if(a &lt;= l &amp;&amp; r &lt;= b) {
      add[k] += x;
      return;
    }
    rangeadd(a, b, x, 2 * k + 1, l, (l + r) &gt;&gt; 1);
    rangeadd(a, b, x, 2 * k + 2, (l + r) &gt;&gt; 1, r);
    Merge(k);
  }

  int rmq(int a, int b)
  {
    return (rmq(a, b, 0, 0, sz));
  }

  void rangeadd(int a, int b, int x)
  {
    return (rangeadd(a, b, x, 0, 0, sz));
  }
};</pre></code>

        <h4>応用 2: 遅延評価</h4>
        <p>遅延評価というテクがある。遅延評価を使うと, 区間に対する演算操作の幅が大きく広がる。
        </p>

        <h4>応用 3: 2Dセグメント木</h4>
        <p>セグメント木のノードに平衡二分探索木をのせた 2Dセグメント木も可能(但し定数倍がかなり重い)。 以下の実装では長方形内の点の個数を求めるクエリと, 点の追加削除のクエリをサポートしている。</p>
        <pre><code class="cpp">#include &lt;ext/pb_ds/assoc_container.hpp&gt;
using namespace __gnu_pbds;	
struct SegmentTree
{
  int sz;
  vector&lt; tree&lt; int, null_type, less&lt; int &gt;, rb_tree_tag, tree_order_statistics_node_update &gt; &gt; seg;

  SegmentTree(int n)
  {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    seg.resize(2 * sz - 1);
  }

  int query(int a, int b, int lower, int upper, int k, int l, int r)
  {
    if(a &gt;= r || b &lt;= l) {
      return (0);
    } else if(a &lt;= l &amp;&amp; r &lt;= b) {
      return (seg[k].order_of_key(upper) - seg[k].order_of_key(lower));
    } else {
      return (query(a, b, lower, upper, 2 * k + 1, l, (l + r) &gt;&gt; 1) + query(a, b, lower, upper, 2 * k + 2, (l + r) &gt;&gt; 1, r));
    }
  }

  int query(int a, int b, int l, int r)
  {
    return (query(a, b, l, r, 0, 0, sz));
  }

  void update(int k, int x, bool type)
  {
    k += sz - 1;
    if(type) seg[k].insert(x);
    else seg[k].erase(x);
    while(k &gt; 0) {
      k = (k - 1) &gt;&gt; 1;
      if(type) seg[k].insert(x);
      else seg[k].erase(x);
    }
  }
};</code></pre>

        <h4>問題例</h4>
        <ul>
	  <li><span class="verified">検証済</span><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A&lang=jp">AOJ DSL_2_A Range Minimum Query (RMQ)</a></li>
          <li><span class="verified">検証済(応用3)</span><a href="http://codeforces.com/contest/785/problem/E">CF #404 E. Anton and Permutation</a>(Submittion: <a href="http://codeforces.com/contest/785/submission/25528699">#25528699</a>)
	</ul>

	<h4>参考資料</h4>
	<ul>
	  <li><a href="http://www.slideshare.net/iwiwi/ss-3578491">プログラミングコンテストでのデータ構造 - iwi</a></li>
	</ul>
      </section>
    </main>
    <hr>
    <footer>
      <small>Copyright&copy; ei1333's page All Rights Reserved.</small>
    </footer>

  </body>
</html>
